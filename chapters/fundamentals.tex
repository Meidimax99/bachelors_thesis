\chapter{Fundamentals} % Main chapter title
\label{chap:fund}

% Hier muss alles rein was benötigt wird um die Arbeit zu verstehen.
%   Man kann ja sicherlich grundlegendes Verständis von Recherstrukturen und Organisation vorraussetzten
%   Was also sollte definitiv nochmal erklärt werden?
%
%   - Virtual Memory -> Und vor allem die Kosten, das ist ja auch irgendwo der Aufhänger
%           Der Satz, "tlb is on the critical path of everything really" sollte irgendwann mal kommen
%   - Motivation für vm
%   - Organisationsstrukturen auch im vergleich -> Fazit: Page Tables sind überall und werden tiefer -> vor allem wegeb backwards compatiblity?
%   - Hardware Strukturen für VM - MMU, TLB
%   - Operating system and VM -> Implemented by OS but fixed structures given by MMU
%   -> Problem, fehlende flexibilität ->  A look at several ...
%   -> source: Architectural and operating system support for virtual memory
%   source: issues of implementation

% -------------------------------------------------------------------------------------------------
% A little bit of history?? -> [Denning VM '96] -> Altas
% -------------------------------------------------------------------------------------------------
Der erste Computer mit virtual memory war Atlas \cite{fotheringham1961dynamic}. Die Grundidee war den
Programmen die Illusion zu schaffen, dass sie einen sehr großen Addressraum für sich alleine haben.
Dieser virtuelle Addressraum war dabei größer als der physische HauptSpeicher selbst.
Damit wurde auch die Aufgabe den physischen Hauptspeicher zu verwalten komplett vom Program gelöst
an das betriebssystem gegeben. Dessen Aufgabe ist war es nun die Teile des virtuellen Speicherbereichs
in den physischen Speicherbereiches zu laden, die auch vom Program in Ausführung benötigt werden.
\cite{denning1970virtual}.
Dies erhöht die Flexibilität für Programme extram, da diese nun nicht nur Daten in ihrem ganzen
virtuellen Addressraum verteilen können, sondern auch größer sein können als der physikalische Speicher
(solang genug Hintegrundspeicher zur Verfügung steht)\todo{CITE}\todo{thrashing irgendwo erwähnen?}.

% -------------------------------------------------------------------------------------------------
%                                           VIRTUAL MEMORY
% -------------------------------------------------------------------------------------------------


\section{Virtual Memory}
\subsection{Motivation}
Virtual memory is used in almost every system, ranging from big data center machines to small embedded system.
Originally, it was developed by the designers of the Atlas Computer to automate the task of swaping data between
main and secondary memory \cite{denning1997before}.

This was necesarry as programs increased in size faster than main memory did; while single programs
still fit in memory, operating systems allowed running multiple programs at once, collectively exceeding
the available physical memory \cite{tanenbaumOS}.

Nowadays, virtual memory is the basis of a lot of memory system requirements such as address
space protection, isolation of processes, shared memory and more \cite{jacobSoftwaremanagedAddressTranslation1997}.
It is also completely transparent to the programmer and enables programms to use every available
address in its virtual address space\cite{jacob1998look}.\\

Peter Denning calls its wide spread adoption ''[..]one of the engineering triumphs of the computer
age.''\cite{denning1997before}.
\subsection{Memory System Requirements/Benefits?}
Inzwischen erfüllt Virtual Memory noch sehr viel mehr Aufgaben als das Tauschen von Seiten in
Haupt und Nebenspeicher zu automatisieren. Virtual Memory Systeme sind Grundlage für
viele weitere Aufgaben und Features des Betriebssystem\cite{jacobSoftwaremanagedAddressTranslation1997}:
\begin{itemize}
    \item Address Space Protection / Isolation / Security
    \item Shared Memory
    \item Large Address Spaces
    \item Fine Grained Protection
    \item Sparse Address Space
    \item Superpages
    \item Memory Mapped Files / IO \cite{tanenbaumOS}
    \item Flexibilität für den Programmieren: Komplette Freiheit der Nutzung des Addressraumes
\end{itemize}
Diese Eigenschaften setzen die meisten Leute die auf Applikationsebene Programmieren mehr oder
weniger als gegeben voraus und machen sich keine weiteren Gedanken darüber\todo{cite?}.
Durch das immer weiter Auseinanderdriften der CPU und Memory geschwindigkeiten und vor allem
durch das größer werden von Addressräumen (von 32 auf 64 bit!) \todo{cite} sind die Ansprüche an
das Virtual Memory system gewachsen und so mussten sich auch die IMplementationen weiterentwickeln.

Im Folgenden werden die meistgenutzten VM systeme betrachtet.
% VM Properties and benefits: Was für Nutzen hat VM?
% Fazit: VM hat sehr nützliche Eigenschaften
% More: jacob1998virtualissues

% -------------------------------------------------------------------------------------------------
%                                IMPLEMENTATION OF VIRTUAL MEMORY
% -------------------------------------------------------------------------------------------------

% Wie können wir VM realisieren? -> Verschiedene Implementationen, Aber hier nicht auf die HW eingehen
%   [ A look at several...]
%   [ Issues of implementation]
\subsection{Implementation of Virtual Memory}
Every virtual memory system has to realize a mapping from virtual addresses of each processes
private, virtual address space to actual physical addresses that index data in main memory.
This section will provide an overview of the most commonly used virtual memory implementation.

\todo{page table splits, vpn -> tanenbaum}
% Naiver Page Table ansatz
Das einfachste wäre natürlich eine große Tabelle mit den virtuellen zu physischen mappings im
speicher zu halten. Bei einem 32 Bit virtuellen zu physischen mapping mit einer typischen Page Größe
von 4 KiBi ( $ 2^{12}$Byte), bräuchte man mindestens 20 Bit pro Page Table Entry (PTE), also mindestestens
\[ 20 * 2^{20} Bit = 20971520 / 8 Byte = 2.5 MiBi \]
pro Page Table. Und da jeder Prozess eine eigene Pagetable braucht um die Isolation und damit Grundlage
für Sicherheit im System zu gewährleisten kann das insgesamt recht teuer werden.
Normalerweise würde man die PTEs auch noch auf wordsize alignen um dann auch noch platz für weitere
Protection flags zu haben, was dann die größe der Pagetable noch auf 4 MiBi erhöhen würde.
Bei 64-bit Computern wäre dieser naiver ansatz völlig unpraktikabel.
\todo{tanenbaum -> numbers for paging}
\subsubsection{Hierarchical page tables}
Um die Speicherkosten der Verwaltung der Pages zu reduzieren benutzten die meisten \todo{cite?}
Virtual Memory Systeme eine Multi-Level Page Table, oder auch hierarchische Page Table genannt.
Diese ähnelt aber in ihrere Struktur weniger einer Tabelle sondern mehr einem Baum dessen Nodes tabellen
von PTEs sind.
Hier wird die Virtuelle Page nummer nochmal in mehrere Teile unterteilt. Jeder Teil der VPN
wird benutzt um eine kleiner Tabelle zu indizieren. Der indizierte PTE verweißt dann auf die
nächste kleinere Page Table, die dann entsprechend mit dem nächsten Teil der VPN indiziert wird.
Je nach implementierung können hier bis zu 5 weitere indirektionen anfallen.
Ein gängiges Schema wie es z.B. in der RISC-V ISA spezifiziert wird ist Sv39, dass insgesamt
3 Level pro Page Table Tree vorsieht\cite{riscvreader}.
\begin{figure*}[t]
    \centering
    \includegraphics[scale=.8]{figures/VM-Tree.pdf}
    \caption[RISC-V Sv39 3-Level Page Tree]{Three-step page walk with a RISC-V Sv39 Page Table Tree:
        The value in the \texttt{satp} register is the base of the root page table; \texttt{VPN[2]}
        is the index into the root page table; the indexed \texttt{PTE} points to the next page table.
        This traversal continues until the bottom of the page table is reached. The last \texttt{PTE}
        contains the \texttt{PPN} of the physical address which can then be combined with the offset
        bits to make the full physical address}
    \label{fig:fund:pagetree}
\end{figure*}

% Fazit -> Viele Main Memory Zugriffe -> Teuer
Das traversieren der Page Table zum finden des Mappings benötigt pro Level eine weitere Memory reference\todo{cite}
und da das Ermitteln des Mappings auf dem kritischen Pfad jeder Memory-operation befindet,  sodass
es im schlimmsten fall, wenn alle caches missen, zu 5 memory accesses kommen muss (bei einem 5 -level
paging scheme) nur um das Mapping für einen Memory Zugriff zu finden.
% Lösung? Hashed!
\subsubsection{Inverted page tables}
\begin{figure*}[t]
    \centering
    \includegraphics[scale=1]{figures/inverted_pt.pdf}
    \caption[Simple Inverted Page Table Design]{A inverted page table has an entry for every physical
        page frame, reducing memory accesses to a minimum of one. Collisions in the hash table (red arrows) can
        make the access much more expensive. }
    \label{fig:fund:pagetree}
\end{figure*}
% Fazit-> Nachteile von Invertierten Page Tables [siehe auch hash dont cache!]
% -> Most commonly used in todays hardware -> Multi level page tables
% Fazit -> Hauptproblem von VM sind teure Hauptspeicherzugriffe im kritischen Pfade von allen Memory Operations

\todo{discussion: Sind die aktuellen VM systeme (vor allem hierachical) noch Zeitgemäß oder nur noch altlast???}
% -------------------------------------------------------------------------------------------------
%                                  END SECTION - VM IMPLEMENTATION
% -------------------------------------------------------------------------------------------------



% -------------------------------------------------------------------------------------------------
%                                            VM HARDWARE
% -------------------------------------------------------------------------------------------------

\section{Memory Management Hardware}
\begin{figure*}[t]
    \centering
    \includegraphics[scale=1.2]{figures/simple_mmu_arch.pdf}
    \caption[A simplified architecture of CPU, MMU and TLB]{A simplified architecture of CPU, MMU and TLB:
        User-level programs running on the \texttt{CPU} try to access main memory with virtual
        addresses; virtual addresses get transparently translated to physical addresses by the
        \texttt{MMU} by either looking up the address in the TLB or by performing a page table
        lookup with the hardware-supported page table design}
    \label{fig:fund:simplearch}
\end{figure*}
% Davor sollte der Page Table walk bekannt sein
\subsection{MMU}
\subsection{TLB}

% With only software ptw process would have to context switch to the kernel -> Very expensive
% With an MMU the processor essentially just freezes until the memory operation has completed
\cite{jacobVirtualMemoryContemporary1998}
% \subsection{HW-Dependent PTE Structure} -> inflexibility
% \subsection{A typical Page Table Walk}



% Fazit -> Es gibt hardware strukturen die VM beschleunigen können, die machen es auch schneller
%       ABER: Die machen die VM Software Systeme auch sehr viel rigider und unflexibler
% Kurze Diskussion -> Machen Hardware strukture das wirklich schneller? [ A look at ...]
% -------------------------------------------------------------------------------------------------

% -------------------------------------------------------------------------------------------------

\section{Sofware-based Virtual Memory System}
% VM in Software möglich mit ähnlicher Performance wie hw möglich -> Sollte ja mehr Flexibilität geben
%   [ A look at several...]
% \section{ Sofware VM Approaches}
% \section{ Liedtke GPTs}
% \subsection{More flexibilty}

\section{HW VM vs SW VM}
% related work will then come in to discuss approaches close to my approach


% -------------------------------------------------------------------------------------------------

% -------------------------------------------------------------------------------------------------

% TODO Short discussion hw and sw vm -> common problem: Page Table Walks require in either case a 
% lot of memory references. These costs can be aleviated using caches, but will still cost [ cite a source abouts costs here]

% -------------------------------------------------------------------------------------------------

% -------------------------------------------------------------------------------------------------

% All approaches are based on a table.
% Überleitung zu meinem Thema -> Avoid all memory references and just have a simple (hash?) function that realizes VM
