\chapter{Theory}
\label{chap:theory}

% Überblick über die Idee schaffen -> Virtueller Speicher durch funktion möglich

% -------------------------------------------------------------------------------------------------
%                                            Intro
% -------------------------------------------------------------------------------------------------


This chapter presents the theoretical foundation of the the implementation presented in the next chapter.
It will start with a short elaboration on the general idea followed by a description of the
programming platform.\\
It then presents the theory behind the different components of the implementation.
% Then?

% -------------------------------------------------------------------------------------------------
%                                            Idea
% -------------------------------------------------------------------------------------------------

\section{The Idea}
% Idea Description


Current hardware-supported virtual memory systems suffer from inflexibility and costly memory accesses.\\
Software-based approaches are a lot more flexible, but are based on page table lookups as well.

This paper is to based on the idea that virtual memory can be realized with a
mapping functions instead of the costly page table walks \cite{van2002memory}.\\


% About the software management
Figure \ref{fig:theory:mapping_fx} depicts the usual lookup approach of hierarchical page tables.
When the TLB misses, the MMU will perform a page table walk through the page table to retrieve the mapping
for the given virtual address.\\
The specification of the MMU binds the software to a specific interface and page table structure. This restricts
the flexibilty of the software.

To provide more flexibility, systems like MIPS allow for TLBs to be managed in software \cite{heiserAnatomyHighPerformanceMicrokernel}.
This still binds the operating system to adhere to the TLB structure, but leaves freedom on how the actual
entry is determined.\\
Virtual memory systems like Jochen Liedtkes Guarded Page Tables \cite{liedtkeGPT} use a table like structure
in combination with the flexible access to TLBs.\\
This flexibility also enables the implementation of alternative approaches that are not based on page tables,
but rather on mapping functions.\\
Figure \ref{fig:theory:mapping_fx} shows what the architecture of a system using a mapping function for
filling the TLB may look like.

% About mapping functions
In this paper, we want to take a closer look at such mapping functions and if a virtual memory system
can be realized without the usual bookkeeping cost of page tables.\\
Good candidates for such functions are non-cryptographic hash functions\todo{elaboration on hash functions}
to create a virtual to physical mapping.



% TODO der Zwischenschritt mit dem Software Page Table walk wird dann in der Impl
% eingeführt

% Normal Page Table Walk
\begin{figure*}[ht!]
    \centering
    \includegraphics[scale=1.5]{figures/theory_normal_tlb_miss.pdf}
    \caption[Usual TLB Miss]{This figure shows what usually happens when the TLB misses:
        the miss will invoke the hardware state machine page table tree walker; the walker traverses
        the page table tree and if a valid PTE is found, the mapping is added to the TLB. The processor
        then executes the failing instruction again which will then result in a TLB hit}
    \label{fig:theory:normal_tlb_miss}
\end{figure*}
% Virtual Memory using a Mapping Function
\begin{figure*}[ht!]
    \centering
    \includegraphics[scale=1.5]{figures/theory_mapping_fx.pdf}
    \caption[Virtual Memory using a mapping function]{Instead of emulating a hardware page table walk in software on
        a TLB Miss exception, a mapping function is invoked that calculates the PTE using arithmetic primitives and tries
        to avoid memory references.}
    \label{fig:theory:mapping_fx}
\end{figure*}


% -------------------------------------------------------------------------------------------------
%                                            Platform
% -------------------------------------------------------------------------------------------------

\section{Platform}
The chosen platform is the xv6 operating system \cite{xv6source}. It is a teaching operating system
used by some MIT courses.\\
xv6 implements the basic Unix Version 6 interfaces, but does so in a very simplified fashion.\\
There is a x86 version and a RISC-V version. For this project, the RISC-V version was chosen.\\
xv6's simplicity and the accompanying handbook \cite{cox2011xv6} make it a good choice for a first
proof of concept.

xv6 will be run on the QEMU \cite{QEMUSource2024} emulator. The QEMU RISC-V emulator implements
all the RISC-V features and extensions that xv6 needs.

Running the operating system on an emulator is a necessity, because the requires the hardware to
throw a TLB Miss exception.\\ The RISC-V ISA does not provide such functionality by default, so
part of the theory and implementation chapters will be dedicated to extending the RISC-V ISA and
the QEMU emulation to support TLB Miss exceptions.
%Implementation Platform
Diese Kapitel betrachtet zwar nur die Theorie des softtlb desings, allerdings muss diese in Kontext
der gewählten Platform gestellt werden und wird daher an manchen Stellen in tieferes Detail der konkreten
Platform eintauchen als man für eine theoretische Ausarbeitung des Designs erwarten würde.
Das ist wichtig um dem späteren Implementierungskapitel den nötigen Kontext zu liefern.\\
Als Platform für die Implementierung wurde der Einfachkeit halber das xv6-riscv educational operating
system \cite{cox2011xv6} gewählt.\\
\textit{Xv6} wird am MIT genutzt um Operating Systems Kurse zu bieten und bietet mit dem Handbuch eine
einfache und verständliche Platform die ein vereinfachtes Unix Version 6 Interface implementiert.\\
Xv6 gibt es in einer x86 version und in einer RISC-V version, es wurde hier die RISC-V version verwendet.
\\
Da im Rahme der Implementierung einer neuen Exception das nutzen echter RISC-V Hardware nicht möglich
ist, muss ein Emulator benutzt werden um die nötigen Änderungen an der ISA zu implementieren und zu nutzen.
Dafür wurde der Qemu Emulator gewählt, da dieser sehr Umfassend und performant ist und außerdem einen
TLB emuliert.
% Zukünftige Idee -> Configurierbarer "stateless" physical frame calculator hw baustein

% Implications of programming platform on implementation -> needing to implement TLB Miss
% -------------------------------------------------------------------------------------------------
% -------------------------------------------------------------------------------------------------
%                                            IMPL THEORY
% -------------------------------------------------------------------------------------------------
% -------------------------------------------------------------------------------------------------


% What to do to realize this idea? (basically top level overview of the theory and impl chapters)
Dieser Abschnitt enthält die theoretischen Ausarbeitungen zu den einzelnen Bestandteilen die für
die Implementation des Software kontrollierten TLB Miss Handlers benötigt werden. Diese Bestandteile
sind wie folgt:
\begin{itemize}
    \item Die Erweiterung des Qemu Emulators um einen Exceptionwurf bei TLB Miss
    \item Einen Maschine-Mode Traphandler in xv6 der die neue TLB Miss Exception entsprechend behandelt
    \item Eine Möglichkeit um TLB einträge mittels spezieller Instruktionen zu schreiben
\end{itemize}

% -------------------------------------------------------------------------------------------------
%                                            Required Changes
% -------------------------------------------------------------------------------------------------
% Conclusion on previous Work -> Still need a memory access

% The Idea -> Getting rid of any memory access in favor of simple arithmetic operation (eg. hash functions)
% statefull -> stateless
% What to do to realize this idea? (basically top level overview of the theory and impl chapters)
% New Exception - TLB Miss Exception
% CSRs to write TLBs
% Exception Handler
% Exception triggerer for testing


% New Exception - TLB Miss Exception
% CSRs to write TLBs
% Exception Handler
% Exception triggerer for testing


% Steps necessary to implement Idea -> relating to the implementation

% Architecture: Handle TLB Miss -> Like Liedtke MIPS

% TLB Exception

% TLB Filling



%elaboration on general costs of page table walks -> basically exactly what related
% work motivated their designs with

% Previous approaches aimed to reduce the memory footprint or optimize cache accesses, or reduce page table
% walks to a minimum, this approach aims to eliminate paging structures completely
While previous work tried to either reduce the number of memory accesses \todo{CITE Lidtke ,Skip no walk, single hit uppsala paper},
decrease the occurrence of a TLB miss and decrease the latency of handling a TLB Miss, this paper
presents an approach to create a virtual memory scheme not requiring paging structures at all.\\

Not unlike the software-managed address translation design presented by Jacob and Mudge \cite{jacobSoftwaremanagedAddressTranslation1997},
the \textit{softtlb} approach utilizes a exception triggered by a cache miss to invoke a software-defined
exception handler.\\
Unlike the \textit{softvm} design, this approach will be based on handling an exception that is triggered
when die TLB misses \todo{TLB and its role explained?}.
The handler code for this \textit{TLB\_Miss} exception will from now on be called \textit{TLB Manager}.

The \textit{TLB Manager}s job is then to resolve the exception by filling the TLB for the failing address
that triggered the exception.





\todo{elaboration on xv6 here or in fundamentals (or an extra platform chapter)?? -> because theory
    may be independent from the platform in big parts, but still needs to be taken into consideration (like with
    csrs)}



% -------------------------------------------------------------------------------------------------
%                                            New Exception
% -------------------------------------------------------------------------------------------------

\section{New Exception}
% Allgemeines über Riscv Exceptions
\todo{ist dieser Abschnitt vielleicht eher der Idee zuzuordnen? So in der Art sollte es
    auf jeden Fall in die Idee, aber vielleicht nicht in diesem Detail, vielleicht nur einmal
    den ''typischen'' controlflow durchgehen und dann einmal den Modifizierten für softtlb}

Damit das Betriebssystem im Falle eines TLB Misses sich um das füllen des TLBs kümmern kann
braucht es zunächst einmal einen Mechanismus um das Betriebssystem wissen zu lassen,
das es zu einem entsprechenden TLB Miss gekommen ist. In Betriebssystemen, die keinen
software managed TLB, wie z.b. MIPS \cite{MIPSArchitectureProgrammers2016} umfassen, ist der
Zugriff auf den TLB in der Regel komplett transparent für das Betriebssystem und somit auch wenn
es zu einem TLB miss kommt. Normalerweiße würde dann die Hardware State Machine aktiviert werden
die dann einen entsprechenden Page Table Walk durchführt um den TLB zu füllen.
\todo{
    explain normal pipeline for TLB misses -> like here + with repeating of fauling instruction
    -> tlb as interface between virtual and physical memory\\
    Aber vielleicht nicht hier
}
Statt das nun aber das MMU anfängt nach dem passenden PTE zu der virtuellen Adresse zu suchen,
soll ein Exception geworfen werden, die das Betriebssystem abfängt um den TLB dann in Software
zu füllen.\\
Im folgenden wird zunächst der allgemeine RISCV-Trap mechanismus betrachtet und dann
wird erleutert wie eine neue Exception in RISC-V hinzugefügt werden kann, bzw. was alles beachtet
werden muss.


% -------------------------------------------------------------------------------------------------
%                                            Exception Handling
% -------------------------------------------------------------------------------------------------
% Catching New Exception
%   Current xv6 machine mode exception handler ( -> maybe too implementation specific)
%   riscv interrupt mechanism (precice, vectorized)
%   Exception Catching theory, context switch, state save restore
\section{TLB Miss exception handling}
% Allgemeines über Exception Handling, Context Switches, etc
\subsection{xv6 exception handling}

% -------------------------------------------------------------------------------------------------
%                                            TLB Writing
% -------------------------------------------------------------------------------------------------
% Writing TLBs -> Implementation Theory
%       Starting with MIPS for inspiration on how instructions for TLB manipulation may look like
%       Then continue with a possible RISCV Implementation Idea
%       I-TLB and D-TLB out of scope
%
\section{TLB modification}

% -------------------------------------------------------------------------------------------------
%   Comparison to MIPS
%       MIPS TLB instructions
%       MIPS TLB entries -> Qemu TLB?
%       Replacement
\subsection{MIPS TLB} % ---------------------------------------------------------------------------

% Inspiration: MIPS
MIPS is a good source of inspiration for a possible CSR format design, since it already provides
instructions to modify the TLB.\\
The MIPS64 instruction set manual \cite{MIPSArchitectureProgrammers2016}
shows a number of different instructions concerned with the invalidation, probing, flushing, reading
and writing (indexed and random).\\
The most interesting for a first design would be the \texttt{TLBWR} instruction for writing a TLB
entry at a random index. With a similar instruction in RISC-V, we can already implement a purely
software-controlled virtual memory system.\\
The other types of TLB instructions that MIPS provides are not strictly necesarry,
except for flushing. Without being able to flush existing translations from the TLB,
user mode processes may try to access physical mappings stemming from other processes.\todo{can this even happen? -> why else would we need to flush the tlb??}
But the RISC-V priviledged Architecture already provides this functionality
with the \texttt{sfence.vma} instruction \cite{riscvreader}.

\paragraph{MIPS - TLBWR} The arguments for the instruction need to be written in some
other registers - \texttt{EntryHi}, \texttt{EntryLo0}, \texttt{EntryLo1} and \texttt{PageMask}.

% \section{L4/MIPS als Vorlage für Software TLB Management in RISCV (Qemu)}
% \subsection{TLB Miss Exception}
% \subsection{TLB Loading instructions}
% \paragraph{tlbwi}
% \paragraph{tlbwr}
% Comparison to MIPS tlb software


% Compare my implementation to a mips one -> Heiser TLB Fastpath
% Fixed TLB format, but flexibilty of CSR format

% Qemu TLB

% Typical TLB entry format

% selective TLB flushing -> RISCV ASIDs (or even no TLB flushing  because VAs contain ASID?)

% How is the RISCV Tlb indexed -> Check Qemu source

% Replacement policy
%   MIPS -> Indexed writes
A advantage of software-managed TLBs is, that the operating system can implement custom
TLB replacement policies, that may even change depending on workload, programs running
and other circumstances.\\
The default replacement strategy for the MIPS \texttt{tlbwr} instruction is to simply
use the value of the \texttt{C0\_RANDOM} register as the index for the next TLB entry
to be replaced. The name of that register is missleading, because it is not actually a
random value, but it is rather decremented on each instruction\cite{heiserAnatomyHighPerformanceMicrokernel}.\\
It is not clear whether this is a sensible replacement strategy,
but it can be used to ensure that the same TLB slot is not used for every \texttt{tlbwr} if the implementation
does not provide for any further replacement strategy.\\
Some TLB entries can be protecte from this ''random'' replacement by setting a value in the \texttt{C0\_WIRED}
register. The value in this register represents a lower bound, protecting all TLB entries that lie below it.\\
This is useful to keep some mappings in the TLB that are valid all the time.

% TODO should this be here? We should probably have a discussion about xv6 first
%Protected TLB entries in xv6 -> Trampoline page
Having a protected space of TLB entries can especially be useful for global mappings. xv6 employs such a global
mapping for every process and the kernel with the trampoline page.\todo{trampoline page should be explained in fundamentals/platform}

% Required Size of CSRs for TLB writing
\begin{figure*}[t]
    \centering
    \begin{bytefield}[bitwidth=\widefigurewidth/39,bitheight=\widthof{~PBMT~}, bitformatting={\tiny\bfseries}, boxformatting={\centering}]{39}
        \bitheader[endianness=big]{38,30,29,21,20,12,11,0} \\
        \bitbox{9}{VPN[2]} &
        \bitbox{9}{VPN[1]} &
        \bitbox{9}{VPN[0]} &
        \bitbox{12}{Page Offset}\\
    \end{bytefield}
    \caption[RISC-V Sv39 Virtual Address]{RISC-V Sv39 Virtual Address}
    \label{fig:theory:sv39va}
\end{figure*}

% -------------------------------------------------------------------------------------------------
% Foundation for RISCV extensibility
%   RISCV CSRs
%       CSRs instructions
%       Data to be communicated to the cpu
%       CSRs chosen Format
\subsection{RISC-V CSR} % -------------------------------------------------------------------------

RISC-V and its extensions currently provide no support for modifying the TLB in software.
RISC-V does however provide a lot of extensibility with the \texttt{Control and Status Registers} (CSRs).\\
CSRs are part of the RISC-V priviledged architecture and are provided by the \texttt{Zicsr} extension\cite{RISCVInstructionSet}.\\



% -------------------------------------------------------------------------------------------------

\subsection{TLB writing via CSRs} % ---------------------------------------------------------------

% Riscv can flush entries of a specific ASID only, this means that it keeps that information
% Somewhere in the TLB structure


% Qemu -> TLB structure, replacement

\todo{TLB CSR Format}

\todo{Hardware dependenc -> still dependent on the TLB structure of RISCV Sv39, VAs and PAs remain, as do PTEs}
% -------------------------------------------------------------------------------------------------
%                                            Exception Handler
% -------------------------------------------------------------------------------------------------
\section{Exception Handler}


% -------------------------------------------------------------------------------------------------
%                                            Mapping Function Design
% -------------------------------------------------------------------------------------------------
\section{Mapping function}
% Assumptions
%Design of Segmented VM softtlb -> Assumption: Process Memory allocation Model -> Only growing upwards
% Segmentation -> ASIDs -> HW support for Address Space Protection
% -> [jacob1998virtualissues]


% A look at input and output data
% Calculation of addresses

% xv6 Perspective and specifcs (but still theory!) -> Into Impl?
%   Special mappings -> special case in tlb manager (e.g. Trampoline)

% End of Theory: A simple mapping function - TLB Manager
%   TODO What does the reader need to know at this point, e.g. what does need to be decided 
%   in theory to create a TLB Miss Handler design??

\subsection{xv6 process memory model}
The new memory system needs to be compatible with the existing one. Otherwise the way xv6
user processes are built and structures needs to be changed.\\
The program memory model of xv6 programs is shown in figure \ref{impl:xv6layout}

\begin{figure*}[t!]
    \centering
    \includegraphics[scale=.5]{figures/prog_vm.pdf}
    \caption[xv6 memory layout]{Virtual memory layout of xv6 processes. Taken from the xv6 book \cite{cox2011xv6}.}
    \label{impl:proclayout}
\end{figure*}

Xv6 processes have their data and text segment and the stack at the very bottom of the virtual
address space \cite{cox2011xv6}.\\
A peak into the implementation of the \texttt{sbrk()} system call also shows us, that the heap
address space grows linearily from low to high addresses.\\
None of the xv6 programs differ from this memory model. There are no pages mapped in the
middle of the address space.\\
The only special cases are the \textit{trampoline} and \textit{trapframe} pages.
\todo{trampoline and trapframe already explained?}

\subsection{Simple Segmented Mapping}

\begin{figure*}[ht!]
    \centering
    \includegraphics[]{figures/segmented_layout.pdf}
    \caption[Segmented Memory Layout]{\textbf{Segmented Memory Layout}}
    \label{fig:theory:segLayout}
\end{figure*}

\begin{figure*}[ht!]
    \centering
    \includegraphics[]{figures/simple_mapping.pdf}

    \caption[Simple Mapping Scheme]{Simple Mapping Scheme}
    \label{fig:theory:simplemapping}
\end{figure*}